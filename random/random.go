package random

import "github.com/sirupsen/logrus"

/*

given a function flip() which simulates a coin-flip and
returns 1 50% of the time and 0 50% of the time, write a function
random(n) that generates a random number between 0 & n-1 with
a normal distribution pattern

*/

// define the flip function contract - no inputs and returns a bool
type flipFunc func() bool

// RandomFunc defines a function which generates a random uint between 0 and arg.
type RandomFunc func(uint) uint

// Let m = 2^k >= n where k is is as small as possible.
// do
//   Let r = random number in 0 .. m-1 generated by k coin flips
// while r >= n
// return r
func NewRandomFunc(flip flipFunc) RandomFunc {
	return func(n uint) uint {
		var r = ^uint(0)

		// figure out min # of bits to describe numbers
		var k uint
		m := nextPowerOf2(n)
		for p := m; p != 0; p >>= 1 {
			k += 1
		}
		logrus.WithField("k", k).Debug("number of bits to set")

		// calculate
		for r >= n {
			var generated, i uint
			for i = 0; i < k-1; i++ {
				if flip() {
					generated |= 1 << i
					logrus.WithField("generated", generated).Debug("flip true")

				} else {
					logrus.WithField("generated", generated).Debug("flip false")
				}
			}
			r = generated
			logrus.WithField("r", r).Debug("number generated")
		}

		return r
	}
}

func nextPowerOf2(n uint) uint {
	if n > 0 && (n&(n-1)) == 0 {
		return n
	}

	var count uint
	for k := n; k != 0; k >>= 1 {
		logrus.WithFields(logrus.Fields{"k": k, "count": count}).Debug("iterating to next power of 2")
		count += 1
	}
	logrus.WithField("nextPower2", 1<<count).Debug("next power number calculated")
	return 1 << count
}

// DefaultRandomFunc is the standard random number generation routine.
func DefaultRandomFunc() RandomFunc {
	return NewRandomFunc(pseudoFlip)
}
